#!/bin/sh
# Install utility for z/OS Open Tools - https://github.com/ZOSOpenTools

export utildir="$( cd "$(dirname "$0")" >/dev/null 2>&1 && pwd -P )"

. "${utildir}/common.inc"

printSyntax() 
{
  args=$*
  echo "zopen download is a utility to download/install a z/OS Open Tools package."
  echo "If you have a Github OAUTH token, export the environment variable ZOPEN_GIT_OAUTH_TOKEN" >&2
  echo "Syntax: zopen download [<option>]* <package, ...>" >&2
  echo "  where <option> may be one or more of:" >&2
  echo "  -u|--update|--upgrade: updates installed z/OS Open Tools packages."  >&2
  echo "  --install-or-upgrade: installs the package if not installed, or upgrades the package if installed."  >&2
  echo "  --reinstall: reinstall already installed z/OS Open Tools packages."  >&2
  echo "  --nosymlink: do not integrate into filesystem through symlink redirection. " >&2
  echo "  -v: run in verbose mode" >&2
  echo "  -d, --download-only: download package to current directory" >&2
  echo "  -l, --local-install: download and unpackage to current directory" >&2
  echo "  and <package> is a list of one or more projects to install" >&2
}

getContentsFromGithub()
{
  url=$1
  printVerbose "Requesting from url:${url}"
  if ! repo_results=$(curl $OAUTH_TOKEN_OPTION "$OAUTH_TOKEN" -s "$url"); then
    printWarning "curl command could not download $url"
  fi
  
  if echo $repo_results | grep -q "API rate limit exceeded for" 2>/dev/null; then
    printError "API rate limit exceeded for github.\n1. Generate a token (https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).\n2. Set ZOPEN_GIT_OAUTH_TOKEN and rerun"
  fi
  if echo $repo_results | grep -q "Bad credentials" 2>/dev/null; then
    printError "Your ZOPEN_GIT_OAUTH_TOKEN is invalid. Please validate that it is correct and re-run."
  fi
  echo "$repo_results";
}

symlinkIntoSystem(){
  if ! $nosymlink; then
    printInfo "Integrating package into file system"

    basedir=$installdir/$name/
    target=$ZOPEN_ROOTFS/usr
    dirs=$(find $basedir -type d | grep -v ".git" | sort -r)
    ndirs=$(echo "$dirs" | wc -l | tr -d ' ')
    dircnt=0
    echo "  ${dircnt}/${ndirs} 0%"
    echo "$dirs" | while read dir; do
      dircnt=$(expr $dircnt + 1)
      trimdir=$(echo $dir | sed "s#^$basedir##")
      if [[ ! "x$trimdir" = "x" ]]; then 
        mkdir -p $target/$trimdir
        filestolink=$(find $dir -type f)
        nfiles=$(echo "$filestolink" | wc -l | tr -d ' ')
        flecnt=0
        pct=0
        ansiupdate 3 -30 "${ERASELINE}Processing ${dircnt} of ${ndirs}: ${pct}% (${flecnt}/${nfiles})"
        echo "$filestolink" | while read filetolink; do
          flecnt=$(expr $flecnt + 1)
          pct=`expr $flecnt \* 100`
          pct=`expr $pct / $nfiles`
          ansiupdate 3 -30 "${ERASELINE}Processing ${dircnt} of ${ndirs}: ${pct}% (${flecnt}/${nfiles})"
          trimfile=$(echo $filetolink | sed "s#^$basedir##")
          lnrc=$(ln -fs $filetolink $target/$trimfile)
          
        done
      fi
    done
    ansiupdate 3 -30 "${ERASELINE}Processed ${ndirs} of ${ndirs}"
    printInfo "Integration complete"
  fi
}

# Run in a subshell to sanitise envvars
installDependencies()
(
  name=$1
  dependencies=$2
  if [ "$dependencies" != "No dependencies" ]; then
    printHeader "Installing dependencies for $name: $dependencies..."
    echo "$dependencies" | xargs | tr ' ' '\n' | sort | while read dep; do
#TODO WOrk out why the need for the heredoc!  
# [track already installed packages? attempting an install would just fail if already installed?]
# [track cyclic dependancies? [most likely!]
 
#    # Remove an old one if it exists
#    rm -f "${name}/.depsenv"
#    varName=$(echo "$name" | sed -e "s/-/_/g")
#    cat <<ZZ >> "${name}/.depsenv"
#${varName}_originalDir="\$OLDPWD"
#ZZ
#    echo "$dependencies" | xargs | tr ' ' '\n' | sort | while read dep; do
#      cat <<ZZ >> "${name}/.depsenv"
#if [ -f "../${dep}/.env" ]; then
#  if [[ \$(type echo) == 'echo is a shell builtin' ]]; then
#    pushd "../${dep}" >/dev/null
#    . ./.env
#    popd >/dev/null
#  else
#    cd "../${dep}" && . ./.env; cd - >/dev/null
#  fi
#fi
#ZZ
      installPort $dep
    done

    cat <<ZZ >> "${name}/.depsenv"
OLDPWD="\$${varName}_originalDir"
ZZ
  fi
)

installPort()
(
  name=$1
  repo="${name}port"

  printHeader "Processing package: $name"
  if ! contents="$(getContentsFromGithub "https://api.github.com/repos/ZOSOpenTools/${repo}/releases/latest")"; then
    exit 4;
  fi

  if [ -z "$contents" ]; then
    printInfo "No releases published for $name"
    continue
  fi

  statusline="$(echo "$contents" | grep "\"body\":.*Test Status:.*(.*)<br />")"

  latestTag="$(echo "$contents" | grep "\"tag_name\":" | cut -d '"' -f 4)"
  printInfo "Release with tag \"${latestTag}\" found for ${name}"
  originalTag=""
  printVerbose "Checking for meta file at: ${ZOPEN_PKGINSTALL}/${name}/.releaseinfo"
  if [ -e "${ZOPEN_PKGINSTALL}/${name}/.releaseinfo" ]; then
    originalTag=$(cat "${ZOPEN_PKGINSTALL}/${name}/.releaseinfo")
    printVerbose "Found originalTag = $originalTag"
  else
    printVerbose "Could not detect existing installation at ${ZOPEN_PKGINSTALL}/${name}"
  fi
  printVerbose "Latest tag=${latestTag};Original=${originalTag};${originalTag};${latestTag};${upgradeInstalled};${installOrUpgrade};${reinstall}"
  if [ "${latestTag}" = "${originalTag}" ]; then
    if ! $reinstall; then
      printInfo "Package ${name} with latest release tag \"${latestTag}\" already installed."
      continue;
    fi
    printInfo "Reinstalling current version of ${name} with release tag \"${originalTag}\"..."
  fi
  printVerbose "Checking if package is not installed but scheduled for upgrade"
  if [ "x" = "x$originalTag" ]; then
    if $upgradeInstalled; then
      printError "Package ${name} can not be upgraded as it is not installed!"
      continue;
    fi
    printInfo "Installing ${name}..."
  else
    printInfo "Replacing ${name} version \"${originalTag}\" with \"${latestTag}\""
  fi

    latest_url="$(echo "$contents" | grep "\"browser_download_url\":" | cut -d '"' -f 4)"
    printVerbose "Checking cache for already downloaded package [file name comparison]"
    pax=$(basename $latest_url)
    if [ -f $pax ]; then
      printInfo "Found existing file '${pax}' in download cache."
    else
      printInfo "Downloading latest release from $repo..."
      if ! $verbose; then
        redirectToDevNull="2>/dev/null"
      fi 
      if ! runAndLog "curl -L ${latest_url} -O ${redirectToDevNull}"; then
        printWarning "Could not download ${latest_url}"
        continue;
      fi
    fi
    if echo "$statusline" | grep "Runtime Dependencies:" >/dev/null; then
      dependencies="$(echo "$statusline" | sed -e "s#.*Runtime Dependencies:<\/b> ##" -e "s#<br />.*##")"
      if $doNotInstallDeps; then
        printInfo "Skipping dependancy installation"
      else
        printInfo "Checking and installing any dependencies"
        installDependencies "$name" "$dependencies"
      fi
    else
      dependencies="No dependencies"
    fi
    
    if ! $downloadOnly; then
      if [ ! -f "${pax}" ]; then
        printError "${pax} was not actually downloaded?"
      fi
      dirname=${pax%.pax.Z} # Use full pax name as default
      if $reduceddirstructure; then
        # get extracted directory
        dirname=$(pax -vf $pax -o listopt="%(name)s" | head -1 | sed -e "s#/\$##")
        printVerbose "Directory name: $dirname"
        if [ -d "$dirname" ]; then
          printInfo "Deleting existing $dirname..."
          rm -rf "$dirname"
        fi
      fi

      printInfo "Extracting $pax..."
      installdir="."
      paxredirect=""
      if ! $localInstall; then
        installdir=$ZOPEN_PKGINSTALL
        paxredirect="-s##$ZOPEN_PKGINSTALL/#"
        printVerbose "Non-local install, extracting with '$paxredirect'"
      fi
      printVerbose "Check for existing directory for version '$dirname'"
      if [ -d $installdir/$dirname ]; then 
        printInfo "Removing existing directory and contents"
        rm -rf $installdir/$dirname
      fi
      if ! runAndLog "pax -rf $pax -p p $paxredirect ${redirectToDevNull}"; then
        printWarning "Could not extract $pax. Skipping"
        continue;
      fi
      if $localInstall; then
        rm -f "${pax}"
      fi
      if $reduceddirstructure; then  
        newDir=$(echo "$dirname" | sed -e "s/\.202[0-9]*_[0-9]*\.zos//g" -e "s/\.zos//g")
        # Using new directory name
        if [ "$newDir" != "$dirname" ]; then
          printVerbose "Moving $dirname to $newDir"
          rm -rf "$newDir"
          mv "$dirname" "$newDir"
          dirname="$newDir"
        fi
      fi
      if [ -L $installdir/$name ]; then
        printVerbose "Removing old symlink '$installdir/$name' and recreating"
        rm -f $installdir/$name
      fi 

      printVerbose "Calulating package install dir (nover/onlyver/buildver)"
      actualdir=$(pax -f $pax|tail -n 1|cut -f1 -d'/')
      if ! ln -s $installdir/$actualdir $installdir/$name; then
        printError "Could not create symbolic link name"
      fi 

      # Add tag information as a .releaseinfo file
      echo "$latestTag" > "${installdir}/${name}/.releaseinfo"
      touch "${installdir}/${name}/.installed"
      if ! $localInstall; then
        symlinkIntoSystem
      fi
      printVerbose "Checking for env file"
      if [ -f ${installdir}/${name}/.env ]; then
         printVerbose ".env file found, adding to profiled processing"
         mkdir -p $ZOPEN_ROOTFS/etc/profiled/$name
cat << EOF > $ZOPEN_ROOTFS/etc/profiled/$name/dotenv
curdir=\$(pwd)
cd "$installdir/$name" >/dev/null 2>&1
if [ -f ".env" ]; then
  . .env
fi
cd \$curdir  >/dev/null 2>&1
EOF
        printVerbose "Re-sourcing environment"
        . $HOME/.zopen-config
      fi
    fi
    printInfo "${NC}${GREEN}Successfully installed $name${NC}"
)

installPorts()
(
  echo "$repoArray" | xargs | tr ' ' '\n' | sort | while read repo; do
    name=${repo%port}
    if ! latest_url="$(getContentsFromGithub "https://api.github.com/repos/ZOSOpenTools/${repo}/releases/latest")"; then
      exit 4;
    fi

    installPort $name
  done
)
# Main code start here
args=$*
upgradeInstalled=false
verbose=false
downloadOnly=false
localInstall=false
reinstall=false
installOrUpgrade=false
nosymlink=false
reduceddirstructure=false
doNotInstallDeps=false
chosenRepos=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    "-u" | "--update" | "-update" | "-upgrade" | "--upgrade")
      upgradeInstalled=true
      ;;
    "-r" | "-reinstall" | "--reinstall")
      reinstall=true
      ;;
    "--install-or-upgrade")
      installOrUpgrade=true
      ;;
    "-l" | "--local-install")
      localInstall=true
      ;;
    "-n" | "--nosymlink")
      nosymlink=true
    ;;
    "-h" | "--h" | "-help" | "--help" | "-?" | "-syntax")
      printSyntax "${args}"
      exit 4
      ;;
    "--nodeps")
      doNotInstallDeps=true
      ;;
    "-d" | "--download-only")
      downloadOnly=true
      ;;
    "-v" | "--v" | "-verbose" | "--verbose")
      verbose=true
      ;;
    *)
      chosenRepos="$chosenRepos $1";
      ;;
  esac
  shift;
done

[[ ! -z "${ZOPEN_CA}" ]] || printError "Internal Error. \$ZOPEN_CA must be set"
[[ -r "${ZOPEN_CA}" ]] || printError "Internal Error. Certificate ${ZOPEN_CA} is required"

export SSL_CERT_FILE="${ZOPEN_CA}"
export GIT_SSL_CAINFO="${ZOPEN_CA}"
export CURL_CA_BUNDLE="${ZOPEN_CA}"

if [ ! -z "${ZOPEN_GIT_OAUTH_TOKEN}" ]; then
  OAUTH_TOKEN_OPTION='-H'
  OAUTH_TOKEN="Authorization: Bearer ${ZOPEN_GIT_OAUTH_TOKEN}" 
else
  printWarning "Setting ZOPEN_GIT_OAUTH_TOKEN is recommended to ensure that you do not hit the GitHub API cap. See --help for more details."
fi

# Retrieve all repositories
if ! repo_results="$(getContentsFromGithub "https://api.github.com/users/ZOSOpenTools/repos?per_page=250")"; then
  exit 4;
fi
repo_results=$(echo "$repo_results" | grep "\"full_name\":" 2>/dev/null | cut -d '"' -f 4)

if $downloadOnly | $localInstall; then
  downloadDir=$PWD
else
  if [ -z "$ZOPEN_ROOTFS" ]; then
    printError "Unable to locate zopen file system, \$ZOPEN_ROOTFS is undefined"
  fi
  downloadDir=$ZOPEN_ROOTFS/var/cache/zopen
fi

if [ ! -d "${downloadDir}" ]; then
  mkdir -p "${downloadDir}"
  if [ $? -gt 0 ]; then
    printError "Could not create download directory: $downloadDir"
  fi
fi

if [ ! -z "${downloadDir}" ] && [ -d "${downloadDir}" ]; then
  cd "${downloadDir}"
fi

printVerbose "Working directory: ${downloadDir}"

# Parse repositories for zopen framework repos
foundPort=false
repoArray=""
for repo in $(echo ${repo_results}); do
  repo=${repo#"ZOSOpenTools/"}
  name=${repo%port}

  # Skip repos that do not end with port
  if [ "${name}" = "${repo}" ]; then
    continue;
  fi

  if [ -z "${chosenRepos}" ]; then
    repoArray="$repoArray $repo"
  else
    for toolrepo in $(echo "${chosenRepos}" | tr ',' '\n'); do
      if [ "${toolrepo}" = "${repo}" ] || [ "${toolrepo}" = "${name}" ]; then
        # Skip if the repo does not end with port
        if [ "${repo}" = "${name}" ]; then
          continue;
        fi
        repoArray="$repoArray $repo"
      fi
    done
  fi
done

if [ -z "$repoArray" ]; then
  printError "Could not find specified $toolrepo. Use 'list' option to view available ports"
fi

installPorts
