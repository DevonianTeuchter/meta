#!/bin/sh
# Query utility for z/OS Open Tools - https://github.com/ZOSOpenTools

export utildir="$( cd "$(dirname "$0")" >/dev/null 2>&1 && pwd -P )"

. "${utildir}/common.inc"

printSyntax() 
{
  args=$*
  echo "zopen query is a utility for z/OS Open Tools to query packages and repos." >&2
  echo "If you have a Github OAUTH token, export the environment variable ZOPEN_GIT_OAUTH_TOKEN" >&2
  echo "Syntax: zopen-query [<option>]* [<package]*" >&2
  echo "  where <option> may be one or more of:" >&2
  echo "  --list: list all available z/OS Open Tools."  >&2
  echo "  --remote-search: check for package in z/OS Open Tools repo" >&2
  echo "  -i : --installed: list install z/OS Open Tools." >&2
#TODO echo " --upgradeable: list packages where an upgrade is available." >&2
#TODO echo "  --provides: list the files that an installed package provides." >&2
  echo "  -wp : --whatprovides: which installed package provided a file." >&2
  echo "  -v: run in verbose mode." >&2
  echo "  -d | --details: include full details for listings." >&2
  echo "  --no-header: suppress the header for the output." >&2
  echo "  --no-version:  suppress version information, return package names." >&2
  echo "  --filter <color>: apply filter based on quality (green - all tests passing, blue - most tests passing, yellow - some tests passing, red - no tests passing, or skipped (no filter by default))"  >&2
  echo " and <package> is an optional list of one or more packages." >&2
}

getContentsFromGithub()
{
  url=$1
  if ! repo_results=$(curl $OAUTH_TOKEN_OPTION "$OAUTH_TOKEN" -s "$url"); then
    printWarning "curl command could not download $url"
  fi
  
  if echo $repo_results | grep -q "API rate limit exceeded for" 2>/dev/null; then
    printError "API rate limit exceeded for github.\n1. Generate a token (https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).\n2. Set ZOPEN_GIT_OAUTH_TOKEN and rerun"
  fi
  if echo $repo_results | grep -q "Bad credentials" 2>/dev/null; then
    printError "Your ZOPEN_GIT_OAUTH_TOKEN is invalid. Please validate that it is correct and re-run."
  fi
  echo "$repo_results";
}

printDetailListEntries()
{
  details=$1
  needle=$2

  if [[ $details -eq 0 ]]; then
    if ! $noheader; then
      printf "${NC}${UNDERLINE}%-15s %-15s %-15s %-15s\n${NC}" "Repo" "Your version" ".version" "Latest Tag"
    fi
    echo "$repoArray" | xargs | tr ' ' '\n' | sort | while read repo; do
      name=${repo%port}
      if [ -z $needle ] || [ "${name}" = "${needle}" ]; then
        if ! contents="$(getContentsFromGithub "https://api.github.com/repos/ZOSOpenTools/${repo}/releases/latest")"; then
          exit 4;
        fi
        latestTag="$(echo "$contents" | grep "\"tag_name\":" | cut -d '"' -f 4)"
        if [ -e "${ZOPEN_PKGINSTALL}/${name}/.releaseinfo" ]; then
          originalTag=$(cat "${ZOPEN_PKGINSTALL}/${name}/.releaseinfo")
        else
          originalTag="Not installed"
        fi
        if [ -e "${ZOPEN_PKGINSTALL}/${name}/.version" ]; then
          dotversion=$(cat "${ZOPEN_PKGINSTALL}/${name}/.version")
        else
          dotversion="N/a"
        fi
        if ! $noversions; then
          printf "%-15s %-15s %-15s %-15s\n" "$repo" "$originalTag" "$dotversion" "$latestTag"
        else
          printf "%s\n" "$repo"
        fi
      fi 
    done
  else
    printVerbose "Checking repoArray: $repoArray"
    if ! $noheader; then
      printf "${NC}${UNDERLINE}%-15s %-15s %-15s %-10s %-25s\n${NC}" "Repo" "Your version" "Latest Tag" "Status" "Quality"
    fi
    echo "$repoArray" | xargs | tr ' ' '\n' | sort | while read repo; do
      name=${repo%port}
      if [ -z $needle ] || [ "${name}" = "${needle}" ]; then
        if ! contents="$(getContentsFromGithub "https://api.github.com/repos/ZOSOpenTools/${repo}/releases/latest")"; then
          exit 4;
        fi
        #FIXME: use jq to parse
        latestTag="$(echo "$contents" | grep "\"tag_name\":" | cut -d '"' -f 4)"
        statusline="$(echo "$contents" | grep "\"body\":.*Test Status:.*(.*)<br />")"
        buildQuality="$(echo "$statusline" | sed -e "s#.*Test Status:<\/b>##" -e "s#[ ]*(.*##" | tr -d ' ')"
        testStatus="$(echo "$statusline" | sed -e "s#.*Test Status:<\/b>[^(]*(##" -e "s#).*##")"
        if [ -z "$buildQuality" ]; then
          buildQuality="Untested"
          testStatus="N/A";
        fi
        if [ ! -z "$filter" ]; then
          qualityLower=$(echo "$buildQuality" | awk '{print tolower($0)}')
          if [ "$filter" != "$qualityLower" ]; then
            continue;
          fi
        fi
        
        if [ -e "${ZOPEN_PKGINSTALL}/${name}/.releaseinfo" ]; then
          originalTag=$(cat "${ZOPEN_PKGINSTALL}/${name}/.releaseinfo")
        else
          originalTag="Not installed"
        fi
        printf "%-15s %-15s %-15s " "$repo" "$originalTag" "$latestTag" 
         case $buildQuality in
          "Green")
          printf "${NC}${GREEN}${1}%-10s${NC}" "$buildQuality"
          ;;
          "Red" | "Untested" | "Skipped" )
          printf "${NC}${RED}${1}%-10s${NC}" "$buildQuality"
          ;;
          "Blue")
          printf "${NC}${BLUE}${1}%-10s${NC}" "$buildQuality"
          ;;
          "Yellow")
          printf "${NC}${YELLOW}${1}%-10s${NC}" "$buildQuality"
          ;;
          *)
          printf "%-10s" "$buildQuality"
          ;;
         esac
        printf " %-25s\n"  "$testStatus"
      fi
      continue;   
    done
  fi
  exit 0
}
printInstalledEntries(){
  if [ ! -z "$1" ] && ! $noheader; then
    printf "${NC}${UNDERLINE}%-15s %-30s %-30s\n${NC}" "Repo" "Installed version" "File version"
  fi
  installedPackages="$(zosfind $ZOPEN_PKGINSTALL -name .active)"
  printVerbose "Packages: $installedPackages"
  echo "$installedPackages" | xargs | tr ' ' '\n' | sort | while read repo; do
    pkghome=$(dirname "${repo}")
    if [ -e "${pkghome}/.releaseinfo" ]; then
      originalTag=$(cat "${pkghome}/.releaseinfo")
    else
      originalTag="N/a"
    fi
    if [ -e "${pkghome}/.version" ]; then
      dotversion=$(cat "${pkghome}/.version")
    else
      dotversion="N/a"
    fi
        
    printVerbose "Original tag: $originalTag for repo: $repo"
    if [ -z "$1" ]; then
      printInfo "$originalTag"
    else
      fileversion="$( cd "$(dirname "$repo")" >/dev/null 2>&1 && pwd -P | xargs basename)"
      reponame=${fileversion%-*}
      if ! $noversions; then
        printf '%-15s %-30s %-30s %-15s\n' "$reponame" "$dotversion" "$fileversion"
      else
        printf "%s\n" "$reponame"
      fi
    fi
  done
  exit 0
}

downloadRepos()
{
    printVerbose "Downloading latest information from repo(s): $repoArray"
    echo "$repoArray" | xargs | tr ' ' '\n' | sort | while read repo; do
    name=${repo%port}
    if ! latest_url="$(getContentsFromGithub "https://api.github.com/repos/ZOSOpenTools/${repo}/releases/latest")"; then
      exit 4;
    fi

    #FIXME: use jq to parse
    statusline="$(echo "$latest_url" | grep "\"body\":.*Test Status:.*(.*)<br />")"
    buildQuality="$(echo "$statusline" | sed -e "s#.*Test Status:<\/b>##" -e "s#[ ]*(.*##" | tr -d ' ')"
    if [ -z "$buildQuality" ]; then
      buildQuality="Untested"
    fi
    if [ ! -z "$filter" ]; then
      qualityLower=$(echo "$buildQuality" | awk '{print tolower($0)}')
      if [ "$filter" != "$qualityLower" ]; then
        continue;
      fi
    fi

    latestTag="$(echo "$latest_url" | grep "\"tag_name\":" | cut -d '"' -f 4)"
    if $updateInstalled; then
      if [ -e "${name}/.releaseinfo" ]; then
        originalTag=$(cat "${name}/.releaseinfo" | xargs) 
      else
        # We're only updating alreaady installed products
        printVerbose "${downloadDir}/${name} will not be updated as it is not installed."
        continue;
      fi
      if [ "${latestTag}" = "${originalTag}" ] && ! $reinstall; then
        printVerbose "${downloadDir}/${name} with latest release tag \"${latestTag}\" already installed. Skipping..."
        continue;
      fi
      printInfo "New release with tag \"${latestTag}\" found for $repo"
    fi
    printInfo "Preparing to download $repo"
    if [ -z "$latest_url" ]; then
      printInfo "No releases published for $repo"
      continue
    fi

    latest_url="$(echo "$latest_url" | grep "\"browser_download_url\":" | cut -d '"' -f 4)"
    printInfo "Downloading latest release from $repo..."
    if ! $verbose; then
      redirectToDevNull="2>/dev/null"
    fi 
    if ! runAndLog "curl -L ${latest_url} -O ${redirectToDevNull}"; then
      printWarning "Could not download ${latest_url}"
      continue;
    fi

    pax=$(basename ${latest_url})
    if [ ! -f "${pax}" ]; then
      printError "${pax} was not actually downloaded?"
    fi

    printInfo "Extracting $pax..."
    if ! runAndLog "pax -rf $pax -p p ${redirectToDevNull}"; then
      printWarning "Could not extract $pax. Skipping"
      continue;
    fi
    rm -f "${pax}"
    dirname=${pax%.pax.Z}

    printVerbose "Removing old symlink and recreating"
    # Remove old symlink and recreate
    if [ -L $name ]; then
      rm $name
    fi 

    if ! ln -s $dirname $name; then
      printError "Could not create symbolic link name"
    fi 

    # Add tag information as a .releaseinfo file
    printVerbose "Adding tag information: $latestTag"
    echo "$latestTag" > "${name}/.releaseinfo"
    printInfo "Successfully downloaded $name to $downloadDir/$name/"
done
}

whatProvides(){
  needle=$1
  printVerbose "Finding matches outside the ZOPEN_PKGINSTALL ($ZOPEN_PKGINSTALL)"
  # Find any symlinks that match the name and can then be dereferenced
  found=$(zosfind $ZOPEN_ROOTFS/usr -type l | grep "${needle}")
  printVerbose "Found? '$found'"
  if [[ -z $found ]]; then
    printInfo "No package provides '${needle}'"
  else
    matches=$(echo "$found"| wc -w | tr -d ' ' ) 
    printInfo "Found ${matches} match$([ $matches = 1 ] && echo "" || echo "es") for regex '${needle}' on the system"
    echo "$found" | xargs | tr ' ' '\n' | while read foundmatch; do
      printVerbose "Parsing $foundmatch"
      if [ ! -d $foundmatch ]; then
        deref=$(ls -l $foundmatch | awk '{ print $(NF) }')
        printVerbose "$ZOPEN_PKGINSTALL  -> $deref"
        printVerbose "${deref#$ZOPEN_PKGINSTALL}"
        pkg=$(echo "${deref#$ZOPEN_PKGINSTALL}" | awk -F/ '{print $2}')
        printInfo "$pkg provides '$foundmatch'"
      fi
    done
  fi
  exit 0
}

# Main code start here
args=$*
verbose=false
noheader=false
noversions=false
localoption=true
details=0
needle=
if [[ $# -eq 0 ]]; then
  printError "No option provided for query"
fi

while [[ $# -gt 0 ]]; do
  printVerbose "Parsing option: $1"
  case "$1" in
    "--list")
      list=1;
      localoption=false;
      ;;
    "-i" | "--installed")
      localoption=true;
      installed=1;
      list=;
    ;;
    "-wp" | "--whatprovides")
      localoption=true;
      whatprovides=1;
      shift;
      [ ! -z $1 ] || printError "Missing file argument";
      needle=$1;
    ;;
    "--remote-search")
      localoption=false;
      remotesearch=1;
      shift;
      [ ! -z $1 ] || printError "Missing package argument";
      needle=$1;
    ;;
    "--no-header")
      noheader=true;
    ;;
    "--no-versions")
      noversions=true;
      noheader=true; # headers do not mean anything without versions!
    ;;
    "-f" | "--filter")
      filter=$2;
      shift
      ;;
    "-d"  | "--details")
      details=1;
    ;;
    "-h" | "--h" | "-help" | "--help" | "-?" | "-syntax")
      printSyntax "${args}"
      exit 4
      ;;
    "-v" | "--v" | "-verbose" | "--verbose")
      verbose=true
      ;;
    -*)
      printError "Unknown option '$1'"
      ;;
     
    *)
      chosenRepos="$chosenRepos $1";
      ;;
  esac
  shift;
done

[[ ! -z "${ZOPEN_CA}" ]] || printError "Internal Error. \$ZOPEN_CA must be set"
[[ -r "${ZOPEN_CA}" ]] ||   printError "Internal Error. Certificate ${ZOPEN_CA} is required"

export SSL_CERT_FILE="${ZOPEN_CA}"
export GIT_SSL_CAINFO="${ZOPEN_CA}"
export CURL_CA_BUNDLE="${ZOPEN_CA}"

if [ ! -z "${ZOPEN_GIT_OAUTH_TOKEN}" ]; then
  OAUTH_TOKEN_OPTION='-H'
  OAUTH_TOKEN="Authorization: Bearer ${ZOPEN_GIT_OAUTH_TOKEN}" 
else
  printWarning "Setting ZOPEN_GIT_OAUTH_TOKEN is recommended to ensure that you do not hit the GitHub API cap. See --help for more details."
fi

if [ ! -z "$filter" ]; then
  filter=$(echo "$filter" | awk '{print tolower($0)}')
  case "$filter" in
      blue|green|yellow|red|skipped) ;;
      *) printError "The filter must be one of blue|green|yellow|red"
  esac
fi

if ! $localoption; then
  # Retrieve all repositories
  if ! repo_results="$(getContentsFromGithub "https://api.github.com/users/ZOSOpenTools/repos?per_page=250")"; then
    exit 4;
  fi
  repo_results=$(echo "$repo_results" | grep "\"full_name\":" 2>/dev/null | cut -d '"' -f 4)
  
  # Parse repositories for zopen framework repos
  foundPort=false
  repoArray=""
  for repo in $(echo ${repo_results}); do
    repo=${repo#"ZOSOpenTools/"}
    name=${repo%port}
    printVerbose "Checking repo '$repo' with name:'$name'"
    # Skip repos that do not end with port
    if [ "${name}" = "${repo}" ]; then
      printVerbose "Skipping ${name}"
      continue;
    fi
  
    if [ -z "${chosenRepos}" ]; then
      repoArray="$repoArray $repo"
    else
      printVerbose "Testing ${chosenRepos}"
      for toolrepo in $(echo "${chosenRepos}" | tr ',' '\n'); do
        if [ "${toolrepo}" = "${repo}" ] || [ "${toolrepo}" = "${name}" ]; then
          # Skip if the repo does not end with port
          if [ "${repo}" = "${name}" ]; then
            continue;
          fi
          repoArray="$repoArray $repo"
        fi
      done
    fi
  done
fi

[[ -z "$remotesearch" ]] || printDetailListEntries $details $needle
[[ -z "$list" ]] || printDetailListEntries $details
[[ -z "$installed" ]] || printInstalledEntries $details
[[ -z "$whatprovides" ]] || whatProvides $needle
downloadRepos
